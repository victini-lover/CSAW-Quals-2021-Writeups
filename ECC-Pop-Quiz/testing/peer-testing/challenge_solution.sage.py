

# This file was *autogenerated* from the file testing/peer-testing/challenge_solution.sage
from sage.all_cmdline import *   # import sage library

_sage_const_2 = Integer(2); _sage_const_3 = Integer(3); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_4 = Integer(4); _sage_const_5 = Integer(5); _sage_const_5002 = Integer(5002); _sage_const_8 = Integer(8)
from pwn import *

def HenselLift(P,p,prec):
	E = P.curve()    
	Eq = E.change_ring(QQ)
	Ep = Eq.change_ring(Qp(p,prec))
	x_P,y_P = P.xy()
	x_lift = ZZ(x_P)
	y_lift = ZZ(y_P)
	x, y, a1, a2, a3, a4, a6 = var('x,y,a1,a2,a3,a4,a6')
	__tmp__=var("a1,a2,a3,a4,a6,x,y"); f = symbolic_expression(y**_sage_const_2  + a1*x*y + a3*y -x**_sage_const_3  -a2*x**_sage_const_2  -a4*x -a6).function(a1,a2,a3,a4,a6,x,y)
	__tmp__=var("y"); g = symbolic_expression(f(ZZ(Eq.a1()),ZZ(Eq.a2()),ZZ(Eq.a3()),ZZ(Eq.a4()),ZZ(Eq.a6()),ZZ(x_P),y)).function(y)
	gDiff = g.diff()
	for i in range(_sage_const_1 ,prec):
		uInv = ZZ(gDiff(y=y_lift))
		u = uInv.inverse_mod(p**i)      
		y_lift= y_lift -u*g(y_lift)
		y_lift = ZZ(Mod(y_lift,p**(i+_sage_const_1 )))
	y_lift = y_lift+O(p**prec)
	return Ep([x_lift,y_lift])

def SmartAttack(P,Q,p,prec):
	E = P.curve()
	Eqq = E.change_ring(QQ)
	Eqp = Eqq.change_ring(Qp(p,prec))
	P_Qp = HenselLift(P,p,prec)     
	Q_Qp = HenselLift(Q,p,prec)     
	p_times_P = p*P_Qp 
	p_times_Q=p*Q_Qp 
	x_P,y_P = p_times_P.xy() 
	x_Q,y_Q = p_times_Q.xy() 
	phi_P = -(x_P/y_P) 
	phi_Q = -(x_Q/y_Q)    
	k = phi_Q/phi_P 
	k = Mod(k,p) 
	return ZZ(k) 

def MovAttack(G,P,p):
	E = P.curve()
	# Find the embedding degree
	# p**k - 1 === 0 (mod order)
	order = E.order()
	k = _sage_const_1 
	while (p**k - _sage_const_1 ) % order:
	    k += _sage_const_1 
	K = GF(p**k, names=('a',)); (a,) = K._first_ngens(1)
	EK = E.base_extend(K)
	PK = EK(P)
	GK = EK(G)
	QK = EK.lift_x(a + _sage_const_2 )  # Independent from PK
	AA = PK.tate_pairing(QK, E.order(), k)
	GG = GK.tate_pairing(QK, E.order(), k)
	dlA = AA.log(GG)
	return dlA

def SingularCurveAttack(P,Q,p):

	F = GF(p)
	x1, y1 = F(P[_sage_const_0 ]), F(P[_sage_const_1 ])
	x2, y2 = F(Q[_sage_const_0 ]), (Q[_sage_const_1 ])
	a = (y1**_sage_const_2  - y2**_sage_const_2 -x1**_sage_const_3  + x2**_sage_const_3 )/(x1 - x2)
	b = y1**_sage_const_2  - x1**_sage_const_3  - a*x1
	#print(f"calculated a : {a}\ncalculated b : {b}")
	P = F['x']; (x,) = P._first_ngens(1)
	f = x**_sage_const_3  + a*x + b
	f_factors = f.factor()
	r = F(f_factors[_sage_const_1 ][_sage_const_0 ] - x)
	# change variables to have the singularity at (0, 0)
	f_ = f.subs(x=x - r)
	x1_ = F(x1 + r)
	x2_ = F(x2 + r)
	P_ = (x1_, y1)
	Q_ = (x2_, y2)
	t = GF(p)(f_.factor()[_sage_const_0 ][_sage_const_0 ]-x).square_root()
	# map both points to F_p
	u = (P_[_sage_const_1 ] + t*P_[_sage_const_0 ])/(P_[_sage_const_1 ] - t*P_[_sage_const_0 ]) % p
	v = (Q_[_sage_const_1 ] + t*Q_[_sage_const_0 ])/(Q_[_sage_const_1 ] - t*Q_[_sage_const_0 ]) % p
	# use Sage to solve the logarithm
	return discrete_log(v, u)


def recv_data():
	return conn.recvuntil(b"What is the value of 'secret'?:")

def extract_params(data, singular=False):
	lines = [line.decode() for line in data.split(b"\r\n") if line != b""]
	#print("***********************************************")
	for line in lines:
		tmp = line[_sage_const_4 :]
		if "???" in tmp:
			continue
		elif "p = " in line:
			p = int(tmp)
			continue
		elif "a = " in line:
			a = int(tmp)
			continue
		elif "b = " in line:
			b = int(tmp)
			continue
		if not singular:
			tmp = line[_sage_const_5 :-_sage_const_5 ].split(" : ")
		else:
			a = "???"
			b = "???"
			tmp = line[_sage_const_5 :-_sage_const_2 ].split("L, ")
			
		if "P1: (" in line:
			P1 = (int(tmp[_sage_const_0 ]), int(tmp[_sage_const_1 ]))
			x1, y1 = P1[_sage_const_0 ], P1[_sage_const_1 ]
			continue
		elif "P2: (" in line:
			P2 = (int(tmp[_sage_const_0 ]), int(tmp[_sage_const_1 ]))
			x2, y2 = P2[_sage_const_0 ], P2[_sage_const_1 ]
			continue
		else:
			continue
	
	return p, a, b, x1, y1, x2, y2

def print_params(p, a, b, x1, y1, x2, y2):
	print(f"p = {p}")
	print(f"a = {a}")
	print(f"b = {b}\n")
	print(f"P1 = {(x1, y1)}")
	print(f"P2 = {(x2, y2)}")

host = "crypto.chal.csaw.io"
port = _sage_const_5002 
popquiz_level = _sage_const_1 
conn = remote(host, port)

while popquiz_level < _sage_const_4 :
	try: 
		if popquiz_level == _sage_const_1 :
			data = recv_data()
			#print(data.decode())
			p, a, b, x1, y1, x2, y2 = extract_params(data)
			#print_params(p, a, b, x1, y1, x2, y2)
			E = EllipticCurve(GF(p), [a, b]) 
			assert (E.order() == p) 
			P1 = E([x1, y1])
			P2 = E([x2, y2])
			k = SmartAttack(P1, P2, p, _sage_const_8 )
			#assert (k*P1 == P2)
			print(f"secret : {k}")
			conn.send(str(k) + "\n")
			popquiz_level += _sage_const_1 
			print("[+] Smart's attack part completed...")
			
		elif popquiz_level == _sage_const_2 :
			data = recv_data()	
			#print(data.decode())
			p, a, b, x1, y1, x2, y2 = extract_params(data)
			#print_params(p, a, b, x1, y1, x2, y2)
			E = EllipticCurve(GF(p), [a, b])
			P1 = E([x1, y1])
			P2 = E([x2, y2])
			k = MovAttack(P1, P2, p)
			#assert (k*P1 == P2)
			print(f"secret : {k}")
			conn.send(str(k) + "\n")
			popquiz_level += _sage_const_1 
			print("[+] MOV attack part completed...")
			
		elif popquiz_level == _sage_const_3 :
			data = recv_data()
			#print(data.decode())
			p, a, b, x1, y1, x2, y2 = extract_params(data, True)
			#print_params(p, a, b, x1, y1, x2, y2)
			P1 = (x1, y1)
			P2 = (x2, y2)
			k = SingularCurveAttack(P1, P2, p)
			#assert (k*P1 == P2)
			print(f"secret : {k}")			
			conn.send(str(k) + "\n")		
			popquiz_level += _sage_const_1 
			print("[+] Singular Curve attack part completed...")			
			break
	except Exception:
		print("Something went wrong, starting over...")
		conn = remote(host, port)
		popquiz_level = _sage_const_1 
		continue

data = conn.recv().decode()
while "flag{" not in data:
	data = conn.recv().decode()
print(data)




















