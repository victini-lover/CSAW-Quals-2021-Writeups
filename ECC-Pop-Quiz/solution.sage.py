

# This file was *autogenerated* from the file solution.sage
from sage.all_cmdline import *   # import sage library

_sage_const_5002 = Integer(5002); _sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_3 = Integer(3); _sage_const_4 = Integer(4); _sage_const_27 = Integer(27)
from pwn import *

#server = remote("127.0.0.1",5000)
server = remote("crypto.chal.csaw.io",_sage_const_5002 )
print(server.recvline())

def SmartAttack():
	print(server.recvline())
	print(server.recvline())
	print(server.recvline())
	p_data = server.recvline().split()
	a_data = server.recvline().split()
	b_data = server.recvline().split()
	p = int(p_data[_sage_const_2 ])
	a = int(a_data[_sage_const_2 ])
	b = int(b_data[_sage_const_2 ])
	print("p =",p,"\na =",a,"\nb =",b)
	print(server.recvline())
	P_data = server.recvline().split(b": ")
	Q_data = server.recvline().split(b": ")
	px = int(P_data[_sage_const_1 ][_sage_const_1 :])
	py = int(P_data[_sage_const_2 ])
	qx = int(Q_data[_sage_const_1 ][_sage_const_1 :])
	qy = int(Q_data[_sage_const_2 ])
	print("P1 =",px,",",py)
	print("P2 =",qx,",",qy)
	print(server.recvline())
	print(server.recvline())
	print(server.recvline())
	E = EllipticCurve(GF(p), [a, b])
	assert(E.order() == p)
	P = E(px,py)
	Q = E(qx,qy)
	Eqp = EllipticCurve(Qp(p, _sage_const_2 ), [ ZZ(t) + randint(_sage_const_0 ,p)*p for t in E.a_invariants() ])
	P_Qps = Eqp.lift_x(ZZ(P.xy()[_sage_const_0 ]), all=True)
	for P_Qp in P_Qps:
		if GF(p)(P_Qp.xy()[_sage_const_1 ]) == P.xy()[_sage_const_1 ]:
			break
	Q_Qps = Eqp.lift_x(ZZ(Q.xy()[_sage_const_0 ]), all=True)
	for Q_Qp in Q_Qps:
		if GF(p)(Q_Qp.xy()[_sage_const_1 ]) == Q.xy()[_sage_const_1 ]:
			break
	p_times_P = p*P_Qp
	p_times_Q = p*Q_Qp
	x_P,y_P = p_times_P.xy()
	x_Q,y_Q = p_times_Q.xy()
	phi_P = -(x_P/y_P)
	phi_Q = -(x_Q/y_Q)
	k = phi_Q/phi_P
	ans = str(ZZ(k))
	print(ans)
	server.sendline(ans)

def mov_attack():
	print(server.recvline())
	print(server.recvline())
	print(server.recvline())
	p_data = server.recvline().split()
	a_data = server.recvline().split()
	b_data = server.recvline().split()
	p = int(p_data[_sage_const_2 ])
	a = int(a_data[_sage_const_2 ])
	b = int(b_data[_sage_const_2 ])
	print("p =",p,"\na =",a,"\nb =",b)
	print(server.recvline())
	P_data = server.recvline().split(b": ")
	Q_data = server.recvline().split(b": ")
	px = int(P_data[_sage_const_1 ][_sage_const_1 :])
	py = int(P_data[_sage_const_2 ])
	qx = int(Q_data[_sage_const_1 ][_sage_const_1 :])
	qy = int(Q_data[_sage_const_2 ])
	print("P1 =",px,",",py)
	print("P2 =",qx,",",qy)
	print(server.recvline())
	print(server.recvline())
	print(server.recvline())
	E = EllipticCurve(GF(p), [a, b])
	order = E.order()
	P = E(px,py)
	Q = E(qx,qy)
	n = P.order()
	k = _sage_const_1 
	while (p**k - _sage_const_1 ) % order:
		k += _sage_const_1 
	K = GF(p**k, names=('a',)); (a,) = K._first_ngens(1)
	EK = E.base_extend(K)
	PK = EK(Q)
	GK = EK(P)
	while True:
		R = EK.random_point()
		m = R.order()
		d = gcd(m,n)
		S = (m//d)*R
		if n / S.order() not in ZZ:
			continue
		if n == S.order():
			break
	alpha = GK.weil_pairing(S,n)
	beta = PK.weil_pairing(S,n)
	dd = beta.log(alpha)
	ans = str(dd)
	print(ans)
	server.sendline(ans)

def singular_curves():
	print(server.recvline())
	print(server.recvline())
	print(server.recvline())
	p_data = server.recvline().split()
	a_data = server.recvline().split()
	b_data = server.recvline().split()
	p = int(p_data[_sage_const_2 ])
	print("p =",p,"\na = ???\nb = ???")
	print(server.recvline())
	G_data = server.recvline().split()
	P_data = server.recvline().split()
	Gx = int(G_data[_sage_const_1 ][_sage_const_1 :-_sage_const_1 ])
	Gy = int(G_data[_sage_const_2 ][:-_sage_const_1 ])
	Px = int(P_data[_sage_const_1 ][_sage_const_1 :-_sage_const_1 ])
	Py = int(P_data[_sage_const_2 ][:-_sage_const_1 ])
	print("P1 =",Gx,",",Gy)
	print("P2 =",Px,",",Py)
	print(server.recvline())
	print(server.recvline())
	print(server.recvline())
	F = GF(p)
	gx = F(Gx)
	gy = F(Gy)
	px = F(Px)
	py = F(Py)
	a = ((gy**_sage_const_2  - py**_sage_const_2 )-(gx**_sage_const_3  - px**_sage_const_3 ))/(gx - px)
	b = gy**_sage_const_2  - (gx**_sage_const_3  + a*gx)
	D = _sage_const_4 *(a**_sage_const_3 ) + _sage_const_27 *(b**_sage_const_2 )
	P = F['x']; (x,) = P._first_ngens(1)
	f = x**_sage_const_3  + a*x + b
	f_factors = f.factor()
	r = F(f_factors[_sage_const_1 ][_sage_const_0 ] - x)
	f_ = f.subs(x=x-r)
	ff = f_.factor()
	t = F(ff[_sage_const_0 ][_sage_const_0 ]-x).square_root()
	u = ((gy + t*(gx+r))/(gy - t*(gx+r)))
	v = ((py + t*(px+r))/(py - t*(px+r)))
	n = discrete_log(v, u)
	ans = str(n)
	print(ans)
	server.sendline(ans)

SmartAttack()
print(server.recvline())
print(server.recvline())
mov_attack()
print(server.recvline())
print(server.recvline())
singular_curves()
server.interactive()
server.close()

